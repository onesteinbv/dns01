#!/usr/bin/env bash

declare -A conf
conf[api]='https://api.openprovider.eu/v1beta'
conf[auth_ep]='auth/login'
conf[auth_req]='username=%s password=%s ip=0.0.0.0'
conf[auth_tok]='.data.token'
conf[auth_var]='OPENPROVIDER_AUTH'

comma_items() {
  local s=$1 depth=0 item=
  for (( i=1; i < ${#s} - 1; i++ )); do
    c=${s:i:1}
    case $c in
      [\[{]) (( depth++ ))                            ;;
      [\]}]) (( depth-- ))                            ;;
          ,) (( !depth )) && [[ -n "$item" ]] && {
               printf '%s\0' "$item"; item=
               continue
             }                                        ;;
    esac
    item+=$c
  done
  [[ -n "$item" ]] && printf '%s\0' "$item"
}

enc() {
  local f="$1"
  shift

  case $f in
    raw) printf "%s\n" "$@" ;;
    uri) { for p in "$@"; do echo "${p%%=*}=$(echo -n "${p#*=}" | jq -sRr @uri)"; done; } | paste -sd '&' ;;
    json)
      local kv_re='^([_A-Za-z][_A-Za-z0-9]*(\.[_A-Za-z][_A-Za-z0-9]*)*)=(.*)$'
      local val_re='^(\{.*\}|\[.*\]|-?[0-9]+([.][0-9]+)?([eE][+-]?[0-9]+)?|true|false|null)$' list_re='^\[.*\]$'
      local json='{}' tok key val

      for tok in "$@"; do
        [[ $tok =~ $kv_re ]] || { echo "error: not a key=value : $tok" >&2; exit 1; }
        key=${BASH_REMATCH[1]} val=${BASH_REMATCH[3]}

        [[ $val =~ $list_re ]] && {
          items=()
          while IFS= read -rd '' item; do
            if [[ $item =~ $list_re ]]; then items+=("$(enc json "item=$item" | jq -c '.item')")
            else [[ $item =~ $val_re ]] && items+=("$item") || items+=("$(printf '"%s"' "$item")")
            fi
          done< <(comma_items "$val")
          val="$(IFS=,; echo "[${items[*]}]")"
        }

        [[ $val =~ $val_re ]] || val="$(printf '%s' "$val" | jq -R '@json') | fromjson"
        json+="|setpath([\"${key//./\",\"}\"]; ($val))"
      done

      jq -n "$json" ;;
  esac
}

req() {
  local encoding=
  [[ $1 == '--raw' ]] && { encoding=raw; shift; }
  local cmd=('curl' '-sSL') endpoint="$1" verb="${FUNCNAME[1]}" client="${FUNCNAME[2]}"
  shift

  [[ $client != 'auth' ]] && {
    [[ -v "${conf[auth_var]}" ]] || auth
    cmd+=('-H' "Authorization: Bearer ${!conf[auth_var]}")
  }

  (( $# )) && case $verb in
    post|put|patch) cmd+=('-H' 'Content-Type: application/json' '-d' "$(enc ${encoding:-json} "$@")") ;;
        get|delete) endpoint+="?$(enc ${encoding:-uri} "$@")"                                       ;;
  esac

  "${cmd[@]}" -X "${verb^^}" "${conf[api]}/$endpoint"
}

auth() {
  local user pass
  read -p  "username: " user
  read -sp "password: " pass

  local req req_arr
  printf -v req "${conf[auth_req]}" "$user" "$pass"
  read -r -a req_arr <<< "$req"

  declare -gx "${conf[auth_var]}"="$(post "${conf[auth_ep]}" "${req_arr[@]}" | jq -r "${conf[auth_tok]}")"
}

go() {
  local verb cmd="$1"

  for verb in post get put delete patch; do
    IFS= read -rd '' verb <<VERB
 ${verb}() { req "\$@"; }
${verb}j() { $verb "\$@" | jq; }
VERB
    eval "$verb"
  done

  [[ $(type -t "${cmd}" 2> /dev/null) == 'function' ]] && "$@"
}

go "$@"

[[ "${BASH_SOURCE[0]}" == "$0" ]] && exit 0

# TODO: improve env save/restore when being sourced
unset conf enc req auth go post get put delete patch postj getj putj deletej patchj
