#!/usr/bin/env bash

# SPDX-License-Identifier: LGPL-3.0-or-later
# Copyright (c) 2025 Onestein B.V.

declare -A script conf

script[path]="$(readlink -f "${BASH_SOURCE[0]}")"
script[name]="${script[path]##*/}"
script[dir]="${script[path]%/*}"

conf[rest_client]="${script[dir]}/rest"
conf[acme_staging]="https://acme-staging-v02.api.letsencrypt.org/directory"
conf[acme_live]="https://acme-v02.api.letsencrypt.org/directory"
conf[acme_email]="acme-challenge@onestein.nl"

# wait_propagation controls
conf[dns01_timeout]=1500
conf[dns01_backoff]=1
conf[dns01_backoff_min]=2
conf[dns01_backoff_max]=32
conf[dns01_streak]=true
conf[dns01_streak_threshold]=10
conf[dns01_streak_penalty]=0
conf[dns01_streak_mod]=4

source "${script[dir]}/common"

alias rest="${conf[rest_client]}"

parse_domain() {
  local domain="$1" wildcard=false fq zone host
  [[ $domain =~ ^(\*\.|)(([^.]+\.)*)([^.]+\.[^.]+)$ ]] && {
    [[ -n "${BASH_REMATCH[1]}" ]] && wildcard=true

    host="${BASH_REMATCH[2]%?}" zone="${BASH_REMATCH[4]}"
    [[ -n $host ]] && fq="$host.$zone" || fq="$zone"

    echo $wildcard "$fq" "$zone" "$host"
  }

  return 1
}

wait_propagation() {
  local name="$1" zone="$2" token="$3"
  local start=$(date +%s) now delta=0 stabilizing=0 stable_threshold stable_p streak_p

  # conf[] tunables
  local timeout="${conf[dns01_timeout]}" backoff="${conf[dns01_backoff]}"
  local backoff_min="${conf[dns01_backoff_min]}" backoff_max="${conf[dns01_backoff_max]}"

  local streak
  # handle bool/integer typing in dns01_streak (should be two vars really)
  case "${conf[dns01_streak]}" in
    true|false) streak=1                        ;;
             *) streak="${conf[dns01_streak]}"
                conf[dns01_streak]=true         ;;
  esac
  local streak_threshold="${conf[dns01_streak_threshold]}"
  local streak_penalty="${conf[dns01_streak_penalty]}"
  local streak_penalty_mod="${conf[dns01_streak_mod]}"

  local nameservers=() i
  for (( i=0; i < 3 && ${#nameservers[@]} == 0; i++ )); do
    msg "Locating authoritative servers for $zone ..."
    readarray -t nameservers< <(dig +short NS "$zone" @8.8.8.8)
    sleep $backoff_min
  done
  (( ${#nameservers[@]} )) || err "Couldn't find authoritative nameservers for $zone - aborting"

  msg "Waiting for TXT propagation ($name.$zone)"
  local test=( "${nameservers[@]}" ) extend_streak
  while (( (extend_streak=${#test[@]} == ${#nameservers[@]}), (now=$(date +%s)) - start < timeout )); do
    for i in "${!test[@]}"; do
      echo -n "${test[$i]}" >&2
      if dig +short TXT "$name.$zone" @"${test[$i]}" | grep -Fq "$token"; then
        echo -n "✅ " >&2

        # lego-style success
        ${conf[dns01_streak]} || {
          echo >&2
          msg "Token propagated in $((now - start))s to all authoritative nameservers"
          return 0
        }

        unset "test[$i]"
      else echo -n "❌ " >&2
      fi
    done
    echo >&2

    test=( "${test[@]}" )

    # some servers failed, continue with those at next iteration
    if (( ${#test[@]} )); then
      # cancel stabilization streaks, penalize streak
      ${conf[dns01_streak]} && (( delta=0, streak=0,
        (streak_penalty++ % streak_penalty_mod) || streak_threshold++ ))

      # increase backoff
      (( backoff=(backoff >= backoff_max ? backoff_max : backoff * 2) ))

    # all servers succeeded, in one iteration (extend_streak=1) or more
    else
      # delta holds the time offset from $start or a previous stabilization
      # 0 means we're starting a fresh stabilization phase
      (( !delta )) && {
        (( (delta=now - (stabilizing ? stabilizing : start)), stabilizing=now ))
        for stable_threshold in 15 30 60 90 120 150 180; do (( delta < stable_threshold * 2 )) && break
        done

        msg "Probing stabilization (Δ${delta}s, total $((now - start))s). Threshold set to ${stable_threshold}s."
      }

      # update streak metrics and backoff
      (( extend_streak && streak++,
        streak_p = (streak * 100 / streak_threshold),
        stable_p = (now - stabilizing) * 100 / stable_threshold,
        backoff=((stabilizing == now && stable_threshold <= 60) ?
          stable_threshold / 2 : (backoff <= backoff_min ? backoff_min : backoff / 2)) ))

      printf 'streak: %s%% (%s/%s), time: %s%% (%s/%s)\n'                 \
        $(( streak_p > 100 ? 100 : streak_p )) $streak $streak_threshold  \
        $(( stable_p > 100 ? 100 : stable_p )) $(( now - stabilizing )) $stable_threshold >&2

      # native-style success
      (( streak_p >= 100 && stable_p >= 100 || streak_p >= 200 )) && {
        msg "Token propagated in $((now - start))s to all authoritative nameservers"
        return 0
      }

      test=( "${nameservers[@]}" )
    fi

    msg "backoff $backoff seconds ..."
    sleep $backoff
  done

  err "Timeout after $((now - start))s waiting for DNS propagation"
}

challenge() {
  local mode="$1" domain="$2" token="$3" wildcard fq zone host
  read -r wildcard fq zone host< <(parse_domain "$domain") || err "Invalid domain syntax: $domain"

  local id
  id=$(rest getj "dns/zones/$zone" | jq -c '.data.id') || return $?
  local name="_acme-challenge${host:+.$host}"

  case $mode in
    add|present)
      rest put dns/zones/"$zone" id="$id" name="$name" \
        records.add="[{
          \"name\" : \"$name\",
          \"type\" : \"TXT\",
          \"ttl\"  : 600,
          \"value\": \"${token}\"
        }]" || return $?                                          ;&

    wait_propagation) wait_propagation "$name" "$zone" "$token"   ;;

    del|cleanup)
      local quoted=$(printf '%s' "$token" | jq -R '@json')

      rest put dns/zones/"$zone" id="$id" \
        records.remove="[{
          \"name\" : \"$name\",
          \"type\" : \"TXT\",
          \"ttl\"  : 600,
          \"value\": $quoted
        }]"                                                       ;;

    *) err "Unknown mode: $mode"                                  ;;
  esac
}

certbot_hook() {
  challenge "$1" "$CERTBOT_DOMAIN" "$CERTBOT_VALIDATION"
}

traefik_hook() {
  local mode="$1" domain="$2" token="$3"
  [[ "$domain" =~ ^_acme-challenge\.(.*)\.$ ]] && domain="${BASH_REMATCH[1]}"

  case "${conf[dns01_native]}" in
    fallback) "${conf[@]@A}" && declare -gA native_conf="${_#*=}"                     ;&

    false)
      conf[dns01_timeout]="$EXEC_PROPAGATION_TIMEOUT"
      conf[dns01_backoff]="$EXEC_POLLING_INTERVAL"
      conf[dns01_backoff_min]="$EXEC_POLLING_INTERVAL"
      conf[dns01_backoff_max]="$EXEC_POLLING_INTERVAL"
      conf[dns01_streak]=false                                                        ;;

    true) true                                                                        ;;

    *)
      [[ -v DNS01_TIMEOUT ]] || {
        [[ -v EXEC_PROPAGATION_TIMEOUT ]] && conf[dns01_timeout]="$EXEC_PROPAGATION_TIMEOUT"
      }

      [[ -v DNS01_BACKOFF ]] || {
        [[ -v EXEC_POLLING_INTERVAL ]] && conf[dns01_backoff]="$EXEC_POLLING_INTERVAL"
      }

      [[ -v DNS01_BACKOFF_MIN ]] || {
        [[ -v EXEC_POLLING_INTERVAL ]] && conf[dns01_backoff_min]="$EXEC_POLLING_INTERVAL"
      }
      [[ -v DNS01_BACKOFF_MAX ]] || {
        [[ -v EXEC_POLLING_INTERVAL ]] && conf[dns01_backoff_max]="$EXEC_POLLING_INTERVAL"
      }

      [[ -v DNS01_STREAK ]] || conf[dns01_streak]=false
      ;;
  esac

  challenge "$mode" "$domain" "$token" || {
    [[ "${conf[dns01_native]}" == 'fallback' ]] && {
      msg "Basic propagation detection failed, trying native streak mode ..."
      "${native_conf[@]@A}" && declare -A conf="${_#*=}"
      conf[dns01_streak]=true
      challenge wait_propagation "$domain" "$token"
    }
  }
}

help() {
  echo "Usage: $0 [--create] [--combo] [--addr <address> ...] [--live] <domain>" >&2
}

go() {
  # map environment  -----------------------------------------------------------
  env2conf DNS01_ "^[0-9]+$" {timeout,streak{,_{threshold,penalty,mod}},backoff{,_{min,max}}}
  env2conf DNS01_ "^(true|false)$" streak
  env2conf DNS01_ "^(true|false|fallback)$" native

  # command dispatch modes -----------------------------------------------------
  local cmd="$1"
  if [[ "$cmd" =~ ^(present|cleanup)$ ]]; then cmd='traefik_hook'
  elif [[ $(type -t "${cmd}" 2> /dev/null) == 'function' ]]; then shift
  else unset cmd
  fi
  [[ -v cmd ]] && { "$cmd" "$@"; return $?; }

  # main / certbot modes -------------------------------------------------------
  local server="${conf[acme_staging]}" create=false combo=false domain addresses=()

  while (( $# )); do
    case $1 in
      --create) create=true                 ;;
       --combo) combo=true                  ;;
        --addr) addresses+=("$2") ; shift   ;;
        --live) server="${conf[acme_live]}" ;;
             *) domain="$1"                 ;;
    esac
    shift
  done

  local wildcard fq zone host
  read -r wildcard fq zone host< <(parse_domain "$domain") || err "Invalid domain syntax: $domain"

  rest get "dns/zones/$zone" &> /dev/null || err "Zone $zone is not hosted at Openprovider - aborting"

  $create && \
    if $wildcard; then msg "Wilcard domain specified - ignoring --create ..."
    elif (( ! ${#addresses[@]} )); then msg "--create specified, but no addresses were given - ignoring ..."
    else
      local address record_type id=

      for address in "${addresses[@]}"; do
        [[ $address == *:* ]] && record_type=AAAA || record_type=A

        rest getj "dns/zones/$zone" with_records=true \
          | jq -e --arg n "$fq" --arg t "$record_type" --arg a "$address" \
          '.data.records[] | select(.name==$n and .type==$t and .value==$a)' &> /dev/null && {
            msg "$fq $record_type $address already exists – skipping"
            continue
          }

        msg "Creating record $fq type $record_type with address $address..."

        id=${id:=$(rest getj "dns/zones/$zone" | jq -c '.data.id')} || return $?

        rest put "dns/zones/$zone" name="$zone" id="$id" \
          records.add="[{
            \"name\":\"$host\",
            \"type\":\"$record_type\",
            \"ttl\":900,
            \"value\":\"$address\"
        }]"
      done
    fi

  local domain_args="-d $domain"
  $combo && { $wildcard && domain_args+=",${domain#*.}" || domain_args+=",*.$domain" ;} || unset combo

  msg "Requesting ${combo:+combo }certificate for $domain ..."

  [[ ! -v conf[certbot_dir] ]] && {
    conf[certbot_dir]="$(mktemp -d)"
    trap 'rm -rf "${conf[certbot_dir]}"' EXIT
  }

  certbot certonly --manual --non-interactive \
    --manual-auth-hook    "${script[path]} certbot_hook add" \
    --manual-cleanup-hook "${script[path]} certbot_hook del" \
    --manual-public-ip-logging-ok \
    --preferred-challenges dns \
    --agree-tos --email "${conf[acme_email]}" \
    --server "$server" \
     $domain_args \
    --config-dir "${conf[certbot_dir]}/etc" \
    --work-dir "${conf[certbot_dir]}/work" \
    --logs-dir "${conf[certbot_dir]}/logs" -v \
  || {
    msg "Certbot failed. Here are the full logs:"
    cat "${conf[certbot_dir]}/logs/letsencrypt.log"
    err "Certbot returned error - aborting"
  }

  cat "${conf[certbot_dir]}/etc/live/${domain#\*.}/"{privkey,fullchain}.pem
}

go "$@"
