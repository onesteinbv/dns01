#!/usr/bin/env bash

declare -A script conf

script[path]="$(readlink -f "${BASH_SOURCE[0]}")"
script[name]="${script[path]##*/}"
script[dir]="${script[path]%/*}"

conf[api]='https://api.openprovider.eu/v1beta'
conf[auth_ep]='auth/login'
conf[auth_req]='username=%s password=%s ip=0.0.0.0'
conf[auth_tok]='.data.token'
conf[auth_var]='OPENPROVIDER_AUTH'

source "${script[dir]}/common"

comma_items() {
  local s=$1 depth=0 item=
  for (( i=1; i < ${#s} - 1; i++ )); do
    c=${s:i:1}
    case $c in
      [\[{]) (( depth++ ))                            ;;
      [\]}]) (( depth-- ))                            ;;
          ,) (( !depth )) && [[ -n "$item" ]] && {
               printf '%s\0' "$item"; item=
               continue
             }                                        ;;
    esac
    item+=$c
  done
  [[ -n "$item" ]] && printf '%s\0' "$item"
}

enc() {
  local f="$1"
  shift

  case $f in
    raw) printf "%s\n" "$@" ;;
    uri) { for p in "$@"; do echo "${p%%=*}=$(echo -n "${p#*=}" | jq -sRr @uri)"; done; } | paste -sd '&' ;;
    json)
      local kv_re='^([_A-Za-z][_A-Za-z0-9]*(\.[_A-Za-z][_A-Za-z0-9]*)*)=(.*)$'
      local val_re='^(\{.*\}|\[.*\]|-?[0-9]+([.][0-9]+)?([eE][+-]?[0-9]+)?|true|false|null)$' list_re='^\[.*\]$'
      local json='{}' tok key val

      for tok in "$@"; do
        [[ $tok =~ $kv_re ]] || err parse "not a key=value : $tok"
        key=${BASH_REMATCH[1]} val=${BASH_REMATCH[3]}

        [[ $val =~ $list_re ]] && {
          items=()
          while IFS= read -rd '' item; do
            if [[ $item =~ $list_re ]]; then
              items+=("$(enc json "item=$item" | jq -c '.item')") || return $?
            else [[ $item =~ $val_re ]] && items+=("$item") || items+=("$(printf '"%s"' "$item")")
            fi
          done< <(comma_items "$val")
          val="$(IFS=,; echo "[${items[*]}]")"
        }

        [[ $val =~ $val_re ]] || val="$(printf '%s' "$val" | jq -R '@json') | fromjson"
        json+="|setpath([\"${key//./\",\"}\"]; ($val))"
      done

      jq -n "$json" || err parse "Parse error in JSON expression: '$json'" ;;
  esac
}

req() {
  local encoding=
  [[ $1 == '--raw' ]] && { encoding=raw; shift; }
  local cmd=('curl' '-sSL') endpoint="$1" verb="${FUNCNAME[1]}" client="${FUNCNAME[2]}"
  shift

  [[ $client != 'auth' ]] && {
    [[ -v "${conf[auth_var]}" ]] || auth || return $?
    cmd+=('-H' "Authorization: Bearer ${!conf[auth_var]}")
  }

  (( $# )) && {
    case $verb in
      post|put|patch) cmd+=('-H' 'Content-Type: application/json' '-d' "$(enc ${encoding:-json} "$@")") ;;
      get|delete) endpoint+="?$(enc ${encoding:-uri} "$@")"                                             ;;
    esac || return $?
  }

  local response status
  response="$("${cmd[@]}" -X "${verb^^}" "${conf[api]}/$endpoint")" || err network "Failed to contact API (curl error)"
  status=$(jq -r '.code? // empty' <<< "$response") || err parse "Invalid JSON response"

  [[ $status =~ ^[0-9]+$ && $status -ne 0 ]] && {
    local message=$(jq -r '.desc // .message // empty' <<< "$response")
    case $status in
      196) err auth $message ;;
        *) err http${status} $message ;;
    esac
    return $?
  }

  echo "$response"
}

auth() {
  local user="${REST_USERNAME:-$1}" pass="${REST_PASSWORD:-$2}" client="${FUNCNAME[1]}"

  [[ -z $user || -z $pass ]] && {
    if [[ -t 0 ]]; then
      [[ -z $user ]] && read  -rp "username: " user
      [[ -z $pass ]] && read -rsp "password: " pass && echo >&2
    else err auth "Missing login data and no TTY for prompt"
    fi
  }

  local -a req
  read -ra req <<< "$(printf "${conf[auth_req]}" "$user" "$pass")"

  local json token
  json="$(post "${conf[auth_ep]}" "${req[@]}")" || return $?
  token="$(jq -er "${conf[auth_tok]}" <<< "$json")" || err parse "Could not extract token"

  declare -gx "${conf[auth_var]}"="$token"
  [[ $client != 'req' ]] && printf '%s' "$token"

  return 0
}

go() {
  local verb cmd="$1"

  for verb in post get put delete patch; do
    IFS= read -rd '' verb <<VERB
 ${verb}() { req "\$@"; }
${verb}j() { $verb "\$@" | jq; }
VERB
    eval "$verb"
  done

  [[ $(type -t "${cmd}" 2> /dev/null) == 'function' ]] && "$@"
}

go "$@"
