#!/usr/bin/env bash

declare -A script=()
script[path]="$(readlink -f "${BASH_SOURCE[0]}")"
script[dir]="${script[path]%/*}"
script[name]="${script[path]##*/}"

declare -A conf
conf[rest_client]="${script[dir]}/rest"
conf[acme_staging]="https://acme-staging-v02.api.letsencrypt.org/directory"
conf[acme_live]="https://acme-v02.api.letsencrypt.org/directory"
conf[acme_email]="acme-challenge@onestein.nl"

log() { printf '[%s] %s\n' "${script[name]}" "$*" >&2; }

parse_domain() {
  local domain="$1" wildcard=false fq
  [[ $domain =~ ^(\*\.|)(([^.]+\.)*)([^.]+\.[^.]+)$ ]] && {
    [[ -n "${BASH_REMATCH[1]}" ]] && wildcard=true
    local host="${BASH_REMATCH[2]%?}" zone="${BASH_REMATCH[4]}"
    [[ -n $host ]] && fq="$host.$zone" || fq="$zone"

    echo $wildcard "$fq" "$zone" "$host"
  }

  return 1
}

# DNS data planes can return flaky results (e.g. from anycast clusters with
# unpredictable zone updates), so we can't trust a single successful test, even
# with all authoritative servers having answered correctly

# Upon a successful test we enter a "stabilizing" phase where we search for
# *sustained streaks* of success, until a stable threshold is reached

# The more it takes reaching this phase, the less we trust the data plane,
# "penalizing" it with higher (time) threshold values. Streak *lengths* have
# their own threshold to meet, and each time a test fails, that may be also
# penalized. How fast the counter penalization extends the streak threshold is
# controlled via $streak_penalty_mod.

# There is a bounded backoff time that slows down when the trend goes toward
# failure, and speeds up as we tend to green results.

# Ultimately success depends on either: 1) both the time and streak thresholds
# being met, or 2) the time threshold being surpassed by 200%. Reaching $timeout
# before those conditions is considered a failure, even in the presence of
# positive test runs. This might be configurable later but as of now the policy
# is strict about this.

wait_propagation() {
  local name="$1" zone="$2" token="$3"
  local start=$(date +%s) now timeout=${4:-1500} backoff=1 min_backoff=2 max_backoff=32
  local delta=0 stabilizing=0 stable_threshold stable_p
  local streak=0 streak_threshold=10 streak_penalty=0 streak_penalty_mod=4 streak_p
  local nameservers=() test=() i

  for (( i=0; i < 3 && ${#nameservers[@]} == 0; i++ )); do
    log "Locating authoritative servers for $zone ..."
    readarray -t nameservers< <(dig +short NS "$zone" @8.8.8.8)
    sleep $min_backoff
  done

  (( ${#nameservers[@]} )) || {
    log "Couldn't find authoritative nameservers for $zone - aborting"
    return 1
  }

  log "Waiting for TXT propagation ($name.$zone)"
  test=( "${nameservers[@]}" )
  while (( (full_test = ${#test[@]} == ${#nameservers[@]}), (now = $(date +%s)) - start < timeout )); do
    for i in "${!test[@]}"; do
      echo -n "${test[$i]}" >&2
      if dig +short TXT "$name.$zone" @"${test[$i]}" | grep -Fq "$token"; then
        echo -n "✅ " >&2
        unset "test[$i]"
      else echo -n "❌ " >&2
      fi
    done
    echo >&2

    test=( "${test[@]}" )
    if (( ${#test[@]} )); then
      (( delta = 0, streak = 0,
         (streak_penalty++ % streak_penalty_mod) || streak_threshold++,
         backoff = (backoff * 2 > max_backoff ? max_backoff : backoff * 2) ))
    else
      (( delta )) || {
        (( (delta = now - (stabilizing ? stabilizing : start)), stabilizing = now ))
        for stable_threshold in 15 30 60 90 120 150 180; do (( delta < stable_threshold * 2 )) && break
        done

        log "Probing stabilization (Δ${delta}s, total $((now - start))s). Threshold set to ${stable_threshold}s."
      }

      (( backoff = ((stabilizing == now && stable_threshold <= 60) ?
           stable_threshold / 2 : (backoff < min_backoff * 2 ? min_backoff : backoff / 2)),
         full_test && streak++,
         streak_p = (streak * 100 / streak_threshold),
         stable_p = (now - stabilizing) * 100 / stable_threshold ))

      printf 'streak: %s%% (%s/%s), time: %s%% (%s/%s)\n'                 \
        $(( streak_p > 100 ? 100 : streak_p )) $streak $streak_threshold  \
        $(( stable_p > 100 ? 100 : stable_p )) $(( now - stabilizing )) $stable_threshold >&2

      (( streak_p >= 100 && stable_p >= 100 || streak_p >= 200 )) && {
        log "Token propagated in $((now - start))s to all authoritative nameservers"
        return 0
      }

      test=( "${nameservers[@]}" )
    fi

    log "backoff $backoff seconds ..."
    sleep $backoff
  done

  echo >&2
  log "Timeout after $((now - start))s waiting for DNS propagation"
  return 1
}

challenge() {
  local mode="$1" domain="$2" token="$3" wildcard fq zone host
  read -r wildcard fq zone host< <(parse_domain "$domain") || { log "Invalid domain syntax: $domain"; return 1; }

  local id=$("${conf[rest_client]}" getj "dns/zones/$zone" | jq -c '.data.id')
  local name="_acme-challenge${host:+.$host}"

  case $mode in
    add|present)
      "${conf[rest_client]}" put dns/zones/"$zone" id="$id" name="$name" \
        records.add="[{
          \"name\" : \"$name\",
          \"type\" : \"TXT\",
          \"ttl\"  : 600,
          \"value\": \"${token}\"
        }]"

      wait_propagation "$name" "$zone" "$token"
      ;;

    del|cleanup)
      local quoted=$(printf '%s' "$token" | jq -R '@json')

      "${conf[rest_client]}" put dns/zones/"$zone" id="$id" \
        records.remove="[{
          \"name\" : \"$name\",
          \"type\" : \"TXT\",
          \"ttl\"  : 600,
          \"value\": $quoted
        }]"
      ;;

    *) log "Unknown mode: $mode"; return 2 ;;
  esac
}

certbot_hook() {
  challenge "$1" "$CERTBOT_DOMAIN" "$CERTBOT_VALIDATION"
}

traefik_hook() {
  local arg mode domain token
  for arg in "$@"; do
    case $arg in
      --mode=*)   mode=${arg#*=}   ;;
      --domain=*) domain=${arg#*=} ;;
      --token=*)  token=${arg#*=}  ;;
    esac
  done
  challenge "$mode" "$domain" "$token"
}

help() {
  echo "Usage: $0 [--create] [--live] domain.tld" >&2
}

go() {
  local cmd="$1"
  [[ $(type -t "${cmd}" 2> /dev/null) == 'function' ]] && { "$@"; return $?; }

  local server="${conf[acme_staging]}" create=false combo=false domain addresses=()

  while (( $# )); do
    case $1 in
      --create) create=true                 ;;
       --combo) combo=true                  ;;
        --addr) addresses+=("$2") ; shift   ;;
        --live) server="${conf[acme_live]}" ;;
             *) domain="$1"                 ;;
    esac
    shift
  done

  local wildcard fq zone host
  read -r wildcard fq zone host< <(parse_domain "$domain") || { log "Invalid domain syntax: $domain"; exit 1; }

  "${conf[rest_client]}" get "dns/zones/$zone" >/dev/null 2>&1 || {
    log "Zone $zone is not hosted at Openprovider - aborting"
    exit 1
  }

  $create && \
    if $wildcard; then log "Wilcard domain specified - ignoring --create ..."
    elif (( ! ${#addresses[@]} )); then log "--create specified, but no addresses were given - ignoring ..."
    else
      local address id= record_type=

      for address in "${addresses[@]}"; do
        [[ $address == *:* ]] && record_type=AAAA || record_type=A

        "${conf[rest_client]}" getj "dns/zones/$zone" with_records=true \
          | jq -e --arg n "$fq" --arg t "$record_type" --arg a "$address" \
          '.data.records[] | select(.name==$n and .type==$t and .value==$a)' >/dev/null && {
            log "$fq $record_type $address already exists – skipping"
            continue
          }

        log "Creating record $fq type $record_type with address $address..."

        local id=${id:=$("${conf[rest_client]}" getj "dns/zones/$zone" | jq -c '.data.id')}

        "${conf[rest_client]}" put "dns/zones/$zone" name="$zone" id="$id" \
          records.add="[{
            \"name\":\"$host\",
            \"type\":\"$record_type\",
            \"ttl\":900,
            \"value\":\"$address\"
        }]"
      done
    fi

  local domain_args="-d $domain"
  $combo && { $wildcard && domain_args+=",${domain#*.}" || domain_args+=",*.$domain" ;} || unset combo

  log "Requesting ${combo:+combo }certificate for $domain ..."

  tmp=$(mktemp -d)
  trap 'rm -rf "$tmp"' EXIT
  certbot certonly --manual --non-interactive \
    --manual-auth-hook    "$0 certbot_hook add" \
    --manual-cleanup-hook "$0 certbot_hook del" \
    --manual-public-ip-logging-ok \
    --preferred-challenges dns \
    --agree-tos --email "${conf[acme_email]}" \
    --server "$server" \
     $domain_args \
    --config-dir "$tmp/etc" --work-dir "$tmp/work" --logs-dir "$tmp/logs" -v \
  || {
    log "Certbot returned an error. Here are the full logs:"
    cat "$tmp/logs/letsencrypt.log"
    exit 1
  }

  cat "$tmp/etc/live/$domain/"{privkey,fullchain}.pem
}

go "$@"
