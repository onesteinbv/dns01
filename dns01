#!/usr/bin/env bash

declare -A script=()
script[path]="$(readlink -f "${BASH_SOURCE[0]}")"
script[dir]="${script[path]%/*}"
script[name]="${script[path]##*/}"

declare -A conf
conf[rest_client]="${script[dir]}/rest"
conf[acme_staging]="https://acme-staging-v02.api.letsencrypt.org/directory"
conf[acme_live]="https://acme-v02.api.letsencrypt.org/directory"
conf[acme_email]="jseijo@smoose.nl"

log() { printf '[dns01] %s\n' "$*" >&2; }

parse_domain() {
  local domain="$1" wildcard=false fq
  [[ $domain =~ ^(\*\.|)(([^.]+\.)*)([^.]+\.[^.]+)$ ]] && {
    [[ -n "${BASH_REMATCH[1]}" ]] && wildcard=true
    local host="${BASH_REMATCH[2]%?}" zone="${BASH_REMATCH[4]}"
    [[ -n $host ]] && fq="$host.$zone" || fq="$zone"

    echo $wildcard "$fq" "$zone" "$host"
  }

  return 1
}

wait_propagation() {
  local record="$1" expect="\"$2\"" timeout=${3:-600} backoff=2 ns nameservers=("8.8.8.8" "1.1.1.1")

  # readarray -t nameservers -O ${#nameservers[@]}< <(dig +short NS "${record#*_acme-challenge.}" @8.8.8.8)

  log "Waiting for TXT propagation ($record)"
  while (( (timeout -= (backoff *= 2)) > 0 )); do
    for ns in "${nameservers[@]}"; do
      dig +short TXT "$record" @"$ns" | grep -Fxq "$expect" && { log "Propagated in ${backoff}s via $ns"; exit 0; }
    done
    sleep "$backoff"
    printf '.' >&2
  done
  echo >&2

  log "Timeout after ${backoff}s waiting for DNS propagation"
  return 1
}

challenge() {
  local mode="$1" domain="$2" token="$3" wildcard fq zone host
  read -r wildcard fq zone host< <(parse_domain "$domain") || { log "Invalid domain syntax: $domain"; exit 1; }

  local id=$("${conf[rest_client]}" getj "dns/zones/$zone" | jq -c '.data.id')
  local name="_acme-challenge${host:+.$host}"

  case $mode in
    add|present)
      "${conf[rest_client]}" put dns/zones/"$zone" id="$id" name="$name" \
        records.add="[{
          \"name\" : \"$name\",
          \"type\" : \"TXT\",
          \"ttl\"  : 600,
          \"value\": \"${token}\"
        }]"

      wait_propagation "${name}.$zone" "$token"
      ;;

    del|cleanup)
      local quoted=$(printf '%s' "$token" | jq -R '@json')

      "${conf[rest_client]}" put dns/zones/"$zone" id="$id" \
        records.remove="[{
          \"name\" : \"$name\",
          \"type\" : \"TXT\",
          \"ttl\"  : 600,
          \"value\": $quoted
        }]"
      ;;

    *) log "Unknown mode: $mode"; return 2 ;;
  esac
}

certbot_hook() {
  challenge "$1" "$CERTBOT_DOMAIN" "$CERTBOT_VALIDATION"
}

traefik_hook() {
  local arg mode domain token
  for arg in "$@"; do
    case $arg in
      --mode=*)   mode=${arg#*=}   ;;
      --domain=*) domain=${arg#*=} ;;
      --token=*)  token=${arg#*=}  ;;
    esac
  done
  challenge "$mode" "$domain" "$token"
}

help() {
  echo "Usage: $0 [--create] [--live] domain.tld" >&2
}

go() {
  local cmd="$1"
  [[ $(type -t "${cmd}" 2> /dev/null) == 'function' ]] && { "$@"; return $?; }

  local server="${conf[acme_staging]}" create=false combo=false domain addresses=()

  while (( $# )); do
    case $1 in
      --create) create=true                 ;;
       --combo) combo=true                  ;;
        --addr) addresses+=("$2") ; shift   ;;
        --live) server="${conf[acme_live]}" ;;
             *) domain="$1"                 ;;
    esac
    shift
  done

  local wildcard fq zone host
  read -r wildcard fq zone host< <(parse_domain "$domain") || { log "Invalid domain syntax: $domain"; exit 1; }

  "${conf[rest_client]}" get "dns/zones/$zone" >/dev/null 2>&1 || {
    log "Zone $zone is not hosted at Openprovider - aborting"
    exit 1
  }

  $create && \
    if $wildcard; then log "Wilcard domain specified - ignoring --create ..."
    elif (( ! ${#addresses[@]} )); then log "--create specified, but no addresses were given - ignoring ..."
    else
      local address id= record_type=

      for address in "${addresses[@]}"; do
        [[ $address == *:* ]] && record_type=AAAA || record_type=A

        "${conf[rest_client]}" getj "dns/zones/$zone" with_records=true \
          | jq -e --arg n "$fq" --arg t "$record_type" --arg a "$address" \
          '.data.records[] | select(.name==$n and .type==$t and .value==$a)' >/dev/null && {
            log "$fq $record_type $address already exists â€“ skipping"
            continue
          }

        log "Creating record $fq type $record_type with address $address..."

        local id=${id:=$("${conf[rest_client]}" getj "dns/zones/$zone" | jq -c '.data.id')}

        "${conf[rest_client]}" put "dns/zones/$zone" name="$zone" id="$id" \
          records.add="[{
            \"name\":\"$host\",
            \"type\":\"$record_type\",
            \"ttl\":900,
            \"value\":\"$address\"
        }]"
      done
    fi

  local domain_args=("-d" "$domain")
  $combo && $wildcard && domain_args+=("-d" "${domain#*.}") || domain_args+=("-d" "*.$domain")

  log "Requesting ${combo:+combo }certificate for $domain ..."

  tmp=$(mktemp -d)
  trap 'rm -rf "$tmp"' EXIT
  certbot certonly --manual --non-interactive \
    --manual-auth-hook    "$0 certbot_hook add" \
    --manual-cleanup-hook "$0 certbot_hook del" \
    --manual-public-ip-logging-ok \
    --preferred-challenges dns \
    --agree-tos --email "${conf[acme_email]}" \
    --server "$server" \
     "${domain_args[@]}" \
    --config-dir "$tmp/etc" --work-dir "$tmp/work" --logs-dir "$tmp/logs" -v

  cat "$tmp/etc/live/$domain/fullchain.pem"
}

go "$@"
