#!/usr/bin/env bash

declare -A script=()
script[path]="$(readlink -f "${BASH_SOURCE[0]}")"
script[dir]="${script[path]%/*}"
script[name]="${script[path]##*/}"

declare -A conf
conf[rest_client]="${script[dir]}/rest"
conf[acme_staging]="https://acme-staging-v02.api.letsencrypt.org/directory"
conf[acme_live]="https://acme-v02.api.letsencrypt.org/directory"
conf[acme_email]="acme-challenge@onestein.nl"

log() { printf '[%s] %s\n' "${script[name]}" "$*" >&2; }

parse_domain() {
  local domain="$1" wildcard=false fq
  [[ $domain =~ ^(\*\.|)(([^.]+\.)*)([^.]+\.[^.]+)$ ]] && {
    [[ -n "${BASH_REMATCH[1]}" ]] && wildcard=true
    local host="${BASH_REMATCH[2]%?}" zone="${BASH_REMATCH[4]}"
    [[ -n $host ]] && fq="$host.$zone" || fq="$zone"

    echo $wildcard "$fq" "$zone" "$host"
  }

  return 1
}

wait_propagation() {
  local name="$1" zone="$2" token="$3"
  local timeout=${4:-1200} backoff=1 max_backoff=45 start=$(date +%s) now=
  local stabilizing=0 delta=0 stable_threshold=0
  local nameservers=() test=() i

  readarray -t nameservers< <(dig +short NS "$zone" @8.8.8.8)
  (( ${#nameservers[@]} )) || {
    log "Couldn't find authoritative nameservers for zone $zone - aborting"
    return 1
  }
  test=( "${nameservers[@]}" )

  log "Waiting for TXT propagation ($name.$zone)"
  while (( (now = $(date +%s)) - start < timeout )); do
    for (( i = ${#test[@]}; i--; )); do
      dig +short TXT "$name.$zone" @"${test[$i]}" | grep -Fq "$token" && unset test[$i]
    done

    test=( "${test[@]}" )
    (( ${#test[@]} )) && {
      stabilizing=0 # cancel any current stabilizing phase

      (( backoff = (backoff * 2 >= max_backoff ? max_backoff : backoff * 2) ))
      printf '%s ' $backoff >&2
      sleep $backoff
      continue
    }

    # DNS data planes can return flaky results (e.g. from anycast clusters with
    # unpredictable zone updates), so we can't trust a single successful test,
    # even with all authoritative servers having answered correctly

    # so upon a successful test, we enter a "stabilizing" phase where we search
    # for *sustained streaks* of success until a stable threshold is reached

    # the more it takes since $start to enter stabilization, the less we trust
    # the data plane, "penalizing" it with higher $stable_threshold values

    # we fail strictly when reaching $timeout before $stable_threshold, even on
    # the presence of successful test runs (this might be configurable later)
    (( stabilizing )) || {
      (( stabilizing = now, delta = now - start ))
      for stable_threshold in 10 30 60 120 240 480 0; do (( delta < stable_threshold )) && break
      done
      (( stable_threshold || (stable_threshold = ((timeout - delta < 10) ? 1 : timeout - delta)) ))
    }

    (( now - stabilizing >= stable_threshold )) && {
      log "\nToken propagated in $((now - start))s to all authoritative nameservers"
      return 0
    }

    test=( "${nameservers[@]}" )
  done

  log "\nTimeout after $((now - start))s waiting for DNS propagation"
  return 1
}

challenge() {
  local mode="$1" domain="$2" token="$3" wildcard fq zone host
  read -r wildcard fq zone host< <(parse_domain "$domain") || { log "Invalid domain syntax: $domain"; return 1; }

  local id=$("${conf[rest_client]}" getj "dns/zones/$zone" | jq -c '.data.id')
  local name="_acme-challenge${host:+.$host}"

  case $mode in
    add|present)
      "${conf[rest_client]}" put dns/zones/"$zone" id="$id" name="$name" \
        records.add="[{
          \"name\" : \"$name\",
          \"type\" : \"TXT\",
          \"ttl\"  : 600,
          \"value\": \"${token}\"
        }]"

      wait_propagation "$name" "$zone" "$token"
      ;;

    del|cleanup)
      local quoted=$(printf '%s' "$token" | jq -R '@json')

      "${conf[rest_client]}" put dns/zones/"$zone" id="$id" \
        records.remove="[{
          \"name\" : \"$name\",
          \"type\" : \"TXT\",
          \"ttl\"  : 600,
          \"value\": $quoted
        }]"
      ;;

    *) log "Unknown mode: $mode"; return 2 ;;
  esac
}

certbot_hook() {
  challenge "$1" "$CERTBOT_DOMAIN" "$CERTBOT_VALIDATION"
}

traefik_hook() {
  local arg mode domain token
  for arg in "$@"; do
    case $arg in
      --mode=*)   mode=${arg#*=}   ;;
      --domain=*) domain=${arg#*=} ;;
      --token=*)  token=${arg#*=}  ;;
    esac
  done
  challenge "$mode" "$domain" "$token"
}

help() {
  echo "Usage: $0 [--create] [--live] domain.tld" >&2
}

go() {
  local cmd="$1"
  [[ $(type -t "${cmd}" 2> /dev/null) == 'function' ]] && { "$@"; return $?; }

  local server="${conf[acme_staging]}" create=false combo=false domain addresses=()

  while (( $# )); do
    case $1 in
      --create) create=true                 ;;
       --combo) combo=true                  ;;
        --addr) addresses+=("$2") ; shift   ;;
        --live) server="${conf[acme_live]}" ;;
             *) domain="$1"                 ;;
    esac
    shift
  done

  local wildcard fq zone host
  read -r wildcard fq zone host< <(parse_domain "$domain") || { log "Invalid domain syntax: $domain"; exit 1; }

  "${conf[rest_client]}" get "dns/zones/$zone" >/dev/null 2>&1 || {
    log "Zone $zone is not hosted at Openprovider - aborting"
    exit 1
  }

  $create && \
    if $wildcard; then log "Wilcard domain specified - ignoring --create ..."
    elif (( ! ${#addresses[@]} )); then log "--create specified, but no addresses were given - ignoring ..."
    else
      local address id= record_type=

      for address in "${addresses[@]}"; do
        [[ $address == *:* ]] && record_type=AAAA || record_type=A

        "${conf[rest_client]}" getj "dns/zones/$zone" with_records=true \
          | jq -e --arg n "$fq" --arg t "$record_type" --arg a "$address" \
          '.data.records[] | select(.name==$n and .type==$t and .value==$a)' >/dev/null && {
            log "$fq $record_type $address already exists â€“ skipping"
            continue
          }

        log "Creating record $fq type $record_type with address $address..."

        local id=${id:=$("${conf[rest_client]}" getj "dns/zones/$zone" | jq -c '.data.id')}

        "${conf[rest_client]}" put "dns/zones/$zone" name="$zone" id="$id" \
          records.add="[{
            \"name\":\"$host\",
            \"type\":\"$record_type\",
            \"ttl\":900,
            \"value\":\"$address\"
        }]"
      done
    fi

  local domain_args="-d $domain"
  $combo && { $wildcard && domain_args+=",${domain#*.}" || domain_args+=",*.$domain" ;} || unset combo

  log "Requesting ${combo:+combo }certificate for $domain ..."

  tmp=$(mktemp -d)
  trap 'rm -rf "$tmp"' EXIT
  certbot certonly --manual --non-interactive \
    --manual-auth-hook    "$0 certbot_hook add" \
    --manual-cleanup-hook "$0 certbot_hook del" \
    --manual-public-ip-logging-ok \
    --preferred-challenges dns \
    --agree-tos --email "${conf[acme_email]}" \
    --server "$server" \
     $domain_args \
    --config-dir "$tmp/etc" --work-dir "$tmp/work" --logs-dir "$tmp/logs" -v \
  || {
    log "Certbot returned an error. Here are the full logs:"
    cat "$tmp/logs/letsencrypt.log"
    exit 1
  }

  cat "$tmp/etc/live/$domain/"{privkey,fullchain}.pem
}

go "$@"
