# Overview

This repository includes tools to handle DNS01 ACME challenges with a focus on Traefik/Lego and Openprovider, although support for other clients and providers should be easy to add with the current code. 

# Components

## `rest`
A minimal script to interact with REST backends similar to httpie, intended for scripting or CLI usage

### requirements

`jq` and `curl`

the code in the `common` script, should be made available at the same directory as this script

### configuration

These entries are expected to be defined in a `conf` associative array:

| `conf[]` entry |                           Defines                            |
| :------------: | :----------------------------------------------------------: |
|     `api`      |       Base URL to where requests are sent (target API)       |
|   `auth_ep`    |     Authentication endpoint path component at target API     |
|   `auth_req`   | A string as per the target API login request format. The first and second `%s` entries are mapped to the user name and password (or analogous secret token). |
|   `auth_tok`   | The JSON node in the reply where to look for the token when authentication succeeds, as per the target API. It must start with a dot ("."). |
|   `auth_var`   | The name of the global variable where to export the authentication token |

 The following variables are used when set in the script or environment:

|    variable     |                           Defines                            |
| :-------------: | :----------------------------------------------------------: |
| `REST_USERNAME` |            The username to use for authentication            |
| `REST_PASSWORD` | The pasword or analogous secret token to use for authentication |

When either `REST_USERNAME` or `REST_PASSWORD` are unset, the script will prompt for them interactively (provided it detects a TTY) and stop until the information is entered.

### usage

Functions in `rest` can be used directly when calling the script by passing them as the first argument, so they can be thought of as subcommands. Useful subcommands are `enc`, `auth` and the autogenerated `req()` wrappers `post`, `get`, `put`, `delete`, `patch` and `postj`, `getj`, `putj`, `deletej`, `patchj`.

#### `enc <format> <k=v> [k=v ...]`

Encodes a series of strings representing key=JSON pairs into the chosen format:

- `raw` format: outputs the raw input using `printf`
-  `uri` format: encodes the input into a query string  
- `json` format: encodes the input into JSON

When using JSON formatting, all key=value input pairs are merged into a top level dictionary that is initially set to `{}`. Each key is a member in that dictionary, and each value is type checked and formatted according to the following rules:

- key and value should be separated by an equal (`=`) character, with no spaces around it
- scalar values and dictionaries go through `jq -R @json` so any recursive formatting in dictionaries is done through this tool 
- lists are explicitly recursive with their items processed separately after using the auxiliary function `comma_items()` to scan for the top level entries inside the currently processed list

Since all scalar values are filtered through `jq`, proper type checking is done for all JSON types. Type checking and any other errors will fail parsing, as will any checks done by this subcommand. 

To avoid brace expansion and any other shell mangling on the input, it is advised to wrap the outermost dictionaries in single quotes:

```bash
./dns01/rest enc json domain='{"extension":"com", "name":"test"}' type=master records=['{"name":"www","ttl":"900","type":"A","value":"1.2.3.4"}','{"name":"ftp","ttl":"900","type":"CNAME","value":"test.com"}']
```

#### `auth [user] [pass]`

Attempts simple HTTP authentication via POST and expects an authentication token as a result. The `auth_` configuration entries control this function's behavior.

User name and password information can be passed as arguments or via `REST_USERNAME` and `REST_PASSWORD`. If these tokens aren't found in the arguments or the environment, the function will prompt for them on a console (provided a TTY is detected) and stop until they are entered.

#### `<post|get|put|delete|patch> [--raw] [k=v ...]`

The request wrapper subcommands merely encode the HTTP method in their name so `req` receives it as an implicit parameter. There is also a second set of wrappers ending in `j` (`postj`, `getj`, `putj`, `deletej`, `patchj`) which pipe the response output to `jq`.

`req` performs the HTTP requests and if there are no errors, prints out the response. An authentication token is expected to be defined in `conf[auth_var]`, otherwise the function will call `auth` in an attempt to get a token prior to sending requests.

The encoding format for `k=v` arguments is selected automatically depending on the method: JSON for post/put/patch and URI for get/delete. The `--raw` argument can be passed first to force that encoding.

## `dns01`
A script to assist with DNS01 ACME challenges.

`dns01` can:

- generate the certificate material from scratch using `certbot`. Wildcard, apex and combo domains (apex+wildcard) are supported.
- create the target A/AAAA records on target DNS APIs (currently only OpenProvider).
- add robust DNS01 challenge detection, with the certificate material managed by clients or `certbot`. This is the operation mode used with lego/traefik, and it can support or be integrated with any client, such as for instance `cert-manager`.

### requirements

`rest` script, `certbot` if using it for certificate generation

the code in the `common` script, should be made available at the same directory as this script

### configuration

These entries are expected to be defined in a `conf` associative array:

| `conf[]` entry |                           Defines                            |
| :------------: | :----------------------------------------------------------: |
|     `api`      |       Base URL to where requests are sent (target API)       |
|   `auth_ep`    |     Authentication endpoint path component at target API     |
|   `auth_req`   | A string as per the target API login request format. The first and second `%s` entries are mapped to the user name and password (or analogous secret token). |
|   `auth_tok`   | The JSON node in the reply where to look for the token when authentication succeeds, as per the target API. It must start with a dot ("."). |
|   `auth_var`   | The name of the global variable where to export the authentication token |

 The following variables are used when set in the script or environment:

|    variable     |                           Defines                            |
| :-------------: | :----------------------------------------------------------: |
| `REST_USERNAME` |            The username to use for authentication            |
| `REST_PASSWORD` | The pasword or analogous secret token to use for authentication |

If either `REST_USERNAME` or `REST_PASSWORD` is unset, the script will prompt for them interactively (provided it detects a TTY) and stop until the information is entered.

#### Internal configuration

##### Environment variables

|         Variable         |             Controls             |      `conf[]` entry      |                            Values                            |
| :----------------------: | :------------------------------: | :----------------------: | :----------------------------------------------------------: |
|      `DNS01_STREAK`      |     Adaptive streak tracking     |      `dns01_streak`      |                      `true` or `false`                       |
| `DNS01_STREAK_THRESHOLD` |     Adaptive streak tracking     | `dns01_streak_threshold` | `<integer value>`: set `conf[]` value<br>`<any other value>`: use `conf[]` value |
|  `DNS01_STREAK_PENALTY`  |     Adaptive streak tracking     | `dns01_streak__penalty`  | `<integer value>`: set `conf[]` value<br/>`<any other value>`: use `conf[]` value |
|    `DNS01_STREAK_MOD`    |     Adaptive streak tracking     |    `dns01_streak_mod`    | `<integer value>`: set `conf[]` value<br/>`<any other value>`: use `conf[]` value |
|     `DNS01_TIMEOUT`      |  Propagation detection timeout   |     `dns01_timeout`      | `<integer value>`: set `conf[]` value<br/>`<any other value>`: use `conf[]` value |
|     `DNS01_BACKOFF`      | Adaptive backoff - initial value |     `dns01_backoff`      | `<integer value>`: set `conf[]` value<br/>`<any other value>`: use `conf[]` value |
|   `DNS01_BACKOFF_MIN`    |  Adaptive backoff - lower bound  |   `dns01_backoff_min`    | `<integer value>`: set `conf[]` value<br/>`<any other value>`: use `conf[]` value |
|   `DNS01_BACKOFF_MAX`    |  Adaptive backoff - upper bound  |   `dns01_backoff_max`    | `<integer value>`: set `conf[]` value<br/>`<any other value>`: use `conf[]` value |
|      `DNS01_NATIVE`      |   Native propagation detection   |      `dns01_native`      | `true`: fully disable lego semantics<br>`false`: fully enable lego semantics (can't be overriden)<br>`fallback`: try `false` behavior first otherwise `true` behavior<br/>(`DNS_*` variables can override)<br>`<any other value>`: enable lego semantics<br/>(`DNS_*` variables can override) |

#### Command line switches



### Propagation detection

#### Adaptive propagation detection

DNS data planes can return flaky results (e.g. from anycast clusters with unpredictable zone updates), so we can't trust a single successful test, even with all authoritative servers having answered correctly.

If we greenlight the challenge propagation only to have LetsEncrypt fail in the face of a flapped NXDOMAIN or stale record, we're in no better position as having had no propagation checks at all.

Thus, the detection logic in the `wait_propagation` function actively tries to detect these worst cases, working with inconsistent data planes to minimize the chance of false positives.

Upon a successful response by all authoritative servers, the process enters a **stabilization phase** where it searchs for *sustained streaks* of success until a stable time threshold is reached. The longer it takes reaching a stabilization phase, the less the data plane is trusted, and the function "penalizes" it with higher time threshold values.

Streak lengths must also meet their own threshold: each time a stabilization phase *breaks* by a failed test, the next one might have to sustain a longer success streak. How often this penalization occurs is controlled via `conf[streak_penalty_mod]`.

There is a bounded backoff time that slows down on falling trends and speeds up as we tend to better results.

Ultimately, success depends on either:

1) both time and streak thresholds being met, or
2) the time threshold being surpassed by 200%

Timing out before 1) or 2) becomes a failure. This might be configurable later, but for now a strict policy is the best defense line against false positives.

#### Performance and reliability

`dns01` is designed to handle DNS data planes that exhibit delayed or inconsistent propagation, but it cannot speed up the underlying DNS provider.

In environments such as OpenProvider, propagation delays and record flapping can occur when multiple TXT records for the same `_acme-challenge` name are created close together, whether from:

- Using the `--combo` option (multiple names in one certificate request)
- Multiple concurrent or closely timed DNS-01 challenges for the same domain from different certificate requests

This is a property of the provider’s backend DNS servers that `dns01` can't avoid. The script’s propagation checker (`wait_propagation`) is designed to maximize the chance of success in poor conditions, but it may extend validation times significantly (10-20 minutes per record in extreme cases).

Possible mitigation routes for faster resolution:

- Avoid `--combo` for automation
- Avoid concurrent or near-concurrent certificate requests for the same domain  
- Use `conf[dns01_timeout]` and related configuration controls to set acceptable timeouts and backoff/streak behavior for your environment

#### Traefik/lego propagation detection

In Traefik mode, the [lego library "exec" provider](https://go-acme.github.io/lego/dns/exec/) sets two environment variables with default values, or configuration from Traefik:

- `EXEC_POLLING_INTERVAL` - Time between DNS propagation check in seconds (Default: 3)
- `EXEC_PROPAGATION_TIMEOUT` - Maximum waiting time for DNS propagation in seconds (Default: 60)

These variables conform to a simpler propagation logic than that of `wait_propagation`. It uses fixed timeout and polling interval, with the first positive challenge resolution considered successful propagation.

The lego variables map to native configuration like this:

|   Traefik/Lego variable    |                        `conf[]` entry                        |                            Notes                             |
| :------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
| `EXEC_PROPAGATION_TIMEOUT` |                       `dns01_timeout`                        |                         1:1 mapping                          |
|  `EXEC_POLLING_INTERVAL`   | `dns01_backoff`<br>`dns01_backoff_min`<br>`dns01_backoff_max` | The `backoff` variable in `wait_propagation` moves in the range, or can be set to a fixed interval |
|             -              | `dns01_streak_threshold`<br>`dns01_streak_penalty`<br>`dns01_streak_mod`<br>`dns01_streak` | Dynamic time/length based streak tracking have no equivalent in Traefik. To follow its semantics `dns01_streak` should be set to `false`. |

When called by Traefik, `dns01` strictly follows the lego model:

- `dns01_timeout` is set to `EXEC_PROPAGATION_TIMEOUT`
- `dns01_backoff`, `dns01_backoff_min` and `dns01_backoff_max` are fixed to `EXEC_POLLING_INTERVAL`
- adaptive streak tracking is disabled

The environment variables `DNS01_STREAK`, `DNS01_TIMEOUT`, `DNS01_BACKOFF_MIN` and `DNS01_BACKOFF_MAX`, when set, allow overriding the lego configuration and propagation semantics with their own as described in [Configuration](#configuration).

Additionally, the variable `DNS01_NATIVE` provides a shortcut to fully use lego or native mode:

- When undefined or set to another value than `true` or `false`, the above rules apply
- When set to `true`, drop lego compatibility and use the native propagation detection, honoring any `DNS01_*` variables
- When set to `false`, ignore all `DNS01_*` variables, force strict mapping and full lego propagation detection
- When set to `fallback`, attempt first the behaviors as if `false` were specified, and if that fails, behave as if `true` was specified

**Note:** when using the lego detection but allowing backoff scaling, the scaling can only be **positive** (ie increased each time we poll negatively for propagation). There won't ever be a negative scaling, as the lego algorithm totally succeeds on the first positive reply.



## `spool.sh`

A generic, single-queue micro spool. It consists of a long-running function as the spooler and a synchronous function to write requests and read responses back. The spooler targets a single program, and a series of arguments are send via the spool files, with the first argument being "the command" sent to the target program. 

This mechanism is used to set up `dns01` as a Traefik `exec` plugin, as described in its own section.

### requirements

### configuration

### usage



## `entrypoint.sh`

The Docker entry point, or just a front end script to control operating modes involving many components or steps.

### requirements

### configuration

### usage

# How to set up and use this code

## Standalone use

The requirements for using the scripts directly are listed in the section about **Components**. Add the `dns01` subdirectory in this repo to your `PATH` (advised) or call the scripts there directly. The code will determine its real location at call time when necessary and find its own components.

The `rest` and `spool.sh` scripts can be used independently provided any requirements are met.

##  Docker image

The docker image uses `entrypoint.sh` to control the operation mode. The mode is selected with the `DNS01_MODE` environment variable.



## Traefik plugin

The following instructions are aimed at Traefik deployments with the official Helm chart. If your setup differs please adjust the definitions accordingly.

As of now the Traefik interface is implemented as an `exec` plugin, until a long-lived listener is developed which will enable using the `httpreq` plugin. The strategy for `exec` is to spawn the `dns01` image as a sidecar in spooled mode, and dispatch the requests by calling the synchronous spool interface from the Traefik container via a shared volume.

We avoid defining `SPOOL_DIR` (the actual spool directory), but ensure that it exists and has proper authorization for the Traefik `exec `plugin. Thus we use the default at `spool.sh`, which targets a `/spool` subdirectory relative to its own path, for which we ensure that both the Docker entrypoint and the Traefik `EXEC_PATH` point to the same location.

### 1) set up the shared volume

```yaml
additionalVolumes:
 - name: acme-scripts
   mountPath: /acme-scripts
   readOnly: false 
```

```yaml
additionalVolumeMounts:
  - name: acme-scripts
    mountPath: /acme-scripts
    readOnly: false
```

Ensure ownership and permissions for the Traefik process:

```yaml
initContainers:
  # The "volume-permissions" init container is required if you run into permission issues.
  # Related issue: https://github.com/traefik/traefik-helm-chart/issues/396
  - name: volume-permissions
    image: busybox:latest
    command:
      - sh
      - -c
      - |
        echo "Setting up /acme-scripts..."
        mkdir -p /acme-scripts/spool
        chown -R <traefik uid>:<traefik gid> /acme-scripts
        chmod -R 700 /acme-scripts
    securityContext:
      runAsNonRoot: false
      runAsUser: 0
      runAsGroup: 0
    volumeMounts:
      - name: acme-scripts
        mountPath: /acme-scripts
```

### 2) set up the spooled `dns01` as a sidecar 

```yaml
additionalContainers:
  - name: dns01
    image: ghcr.io/3coma3/dns01:latest
    imagePullPolicy: Always
    volumeMounts:
      - name: acme-scripts
        mountPath: /acme-scripts
        readOnly: false
    env:
    - name: REST_USERNAME
      valueFrom:
        secretKeyRef:
          name: traefik
          key: openprovider_username
    - name: REST_PASSWORD
      valueFrom:
        secretKeyRef:
          name: traefik
          key: openprovider_password
    - name: DNS01_MODE
      value: spool
    - name: DNS01_SPOOL
      value: /acme-scripts
    - name: DNS01_NATIVE
      value: "true" 
```

### 3) set up the synchronous spool interface as a Traefik `exec` plugin

```yaml
env:
- name: EXEC_PATH
  value: /acme-scripts/spool.sh
    
certificatesResolvers:
  dns01:
    acme:
      email: acme-challenge@onestein.nl
      storage: /data/acme.json
      tlsChallenge: false
      httpChallenge: false
      dnsChallenge:
        provider: exec
        disablePropagationCheck: true
```

**note**: in this case, `/data` is a persistent volume. Refer to the Traefik documentation on ACME certificate stores for more information.
